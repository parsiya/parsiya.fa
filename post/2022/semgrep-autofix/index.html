<!doctype html><html lang=fa dir=rtl><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>قابلیت ترمیم خودکار Semgrep | امنیت و غیره به فارسی</title><meta name=keywords content><meta name=description content="در این نوشتار می‌خواهم در مورد قابلیت ترمیمِ خودکار (autofix) کُد Semgrep صحبت کنم. این قابلیت آزمایشی به ما امکان می‌دهد که بعد از یافتن نتایج در فایلهای منبع، آنها را به صورت اتوماتیک دستکاری کنیم.
اگر علاقه به خواندن نسخه انگلیسی دارید:
https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/ همه نمونه‌ها در Semgrep playground هستند ولی می‌توانید آنها را آفلاین نیز اجرا کنید:
https://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix پیش‌نیازهای این بلاگ برای استفاده بهینه از این بلاگ، بهتر است این موارد را بدانید:"><meta name=author content="پارسیا"><link rel=canonical href=https://parsiya.github.io/parsiya.fa/post/2022/semgrep-autofix/><link href=/parsiya.fa/assets/css/stylesheet.min.d08f6c302eba3eaecd589684c093cecdfe7dfb8745a207401bd0583d3bb31837.css integrity="sha256-0I9sMC66Pq7NWJaEwJPOzf59+4dFogdAG9BYPTuzGDc=" rel="preload stylesheet" as=style><link rel=icon href=https://parsiya.github.io/parsiya.fa/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://parsiya.github.io/parsiya.fa/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://parsiya.github.io/parsiya.fa/favicon-32x32.png><link rel=apple-touch-icon href=https://parsiya.github.io/parsiya.fa/apple-touch-icon.png><link rel=mask-icon href=https://parsiya.github.io/parsiya.fa/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><link rel=stylesheet href=https://parsiya.github.io/parsiya.fa/css/vazir-font.css><link rel=stylesheet href=https://parsiya.github.io/parsiya.fa/css/custom.css><meta property="og:title" content="قابلیت ترمیم خودکار Semgrep"><meta property="og:description" content="در این نوشتار می‌خواهم در مورد قابلیت ترمیمِ خودکار (autofix) کُد Semgrep صحبت کنم. این قابلیت آزمایشی به ما امکان می‌دهد که بعد از یافتن نتایج در فایلهای منبع، آنها را به صورت اتوماتیک دستکاری کنیم.
اگر علاقه به خواندن نسخه انگلیسی دارید:
https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/ همه نمونه‌ها در Semgrep playground هستند ولی می‌توانید آنها را آفلاین نیز اجرا کنید:
https://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix پیش‌نیازهای این بلاگ برای استفاده بهینه از این بلاگ، بهتر است این موارد را بدانید:"><meta property="og:type" content="article"><meta property="og:url" content="https://parsiya.github.io/parsiya.fa/post/2022/semgrep-autofix/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-04-23T11:40:33-07:00"><meta property="article:modified_time" content="2022-04-23T11:40:33-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="قابلیت ترمیم خودکار Semgrep"><meta name=twitter:description content="در این نوشتار می‌خواهم در مورد قابلیت ترمیمِ خودکار (autofix) کُد Semgrep صحبت کنم. این قابلیت آزمایشی به ما امکان می‌دهد که بعد از یافتن نتایج در فایلهای منبع، آنها را به صورت اتوماتیک دستکاری کنیم.
اگر علاقه به خواندن نسخه انگلیسی دارید:
https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/ همه نمونه‌ها در Semgrep playground هستند ولی می‌توانید آنها را آفلاین نیز اجرا کنید:
https://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix پیش‌نیازهای این بلاگ برای استفاده بهینه از این بلاگ، بهتر است این موارد را بدانید:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parsiya.github.io/parsiya.fa/post/"},{"@type":"ListItem","position":2,"name":"قابلیت ترمیم خودکار Semgrep","item":"https://parsiya.github.io/parsiya.fa/post/2022/semgrep-autofix/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"قابلیت ترمیم خودکار Semgrep","name":"قابلیت ترمیم خودکار Semgrep","description":"در این نوشتار می‌خواهم در مورد قابلیت ترمیمِ خودکار (autofix) کُد Semgrep صحبت کنم. این قابلیت آزمایشی به ما امکان می‌دهد که بعد از یافتن نتایج در فایلهای منبع، آنها را به صورت اتوماتیک دستکاری کنیم.\nاگر علاقه به خواندن نسخه انگلیسی دارید:\nhttps://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/ همه نمونه‌ها در Semgrep playground هستند ولی می‌توانید آنها را آفلاین نیز اجرا کنید:\nhttps://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix پیش‌نیازهای این بلاگ برای استفاده بهینه از این بلاگ، بهتر است این موارد را بدانید:","keywords":[],"articleBody":"در این نوشتار می‌خواهم در مورد قابلیت ترمیمِ خودکار (autofix) کُد Semgrep صحبت کنم. این قابلیت آزمایشی به ما امکان می‌دهد که بعد از یافتن نتایج در فایلهای منبع، آنها را به صورت اتوماتیک دستکاری کنیم.\nاگر علاقه به خواندن نسخه انگلیسی دارید:\nhttps://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/ همه نمونه‌ها در Semgrep playground هستند ولی می‌توانید آنها را آفلاین نیز اجرا کنید:\nhttps://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix پیش‌نیازهای این بلاگ برای استفاده بهینه از این بلاگ، بهتر است این موارد را بدانید:\nاستفاده از Semgrep و نوشتن rule (قانون؟). چرا از Semgrep برای Static Analysis استفاده کنیم؟ را بخوانید. آشنایی سَرسَری با خواندن کدُ Java، Python و Go. آشنایی مختصر با بعضی مفاهیم امنیت مانند HttpOnly و XSS. نکته: ترمیمِ خودکار، یکی از قابلیت‌های آزمایشی Semgrep است. در زمان نگارش (آوریل 2022 برای نسخه فارسی و اکتبر 2021 برای نسخه انگلیسی) همه مثال‌ها درست هستند. اگر از آینده میایید، شاید بعضی چیزها متفاوت باشند.\nاجرای قوانین برای اجرا و تست قوانین دو راه داریم:\nاستفاده از Semgrep playground در آدرس https://semgrep.dev/playground. من بیشتر از این روش استفاده می‌کنم چون راحت و سریع می‏‌توانم قانون را عوض کنم و نتیجه را ببینم. اجرا در خطِ فرمان (ترجمه فارسی command line). بعد از نوشتن یک قانون می‌توانید درستی ساختار فایل yaml آن را تست کنید:\nsemgrep-crule1.yaml--validate اگر یک قانون دارای بخش autofix باشد، هنگام اجرا فایل اصلی دستکاری نمی‌شود ولی می‌توانید تغییرات را ببینید. برای تغییر فایل اصلی از سویچ autofix-- استفاده کنید. برای مشاهده تغییرات بدون تغییر فایل اصلی از سویچ dry-run-- استفاده کنید (حضور همزمان autofix و dry-run معادل نبودِ autofix است یعنی تغییرات فقط نشان داده می‌شوند):\nsemgrep -c rule1.yaml example.java --autofix --dryrun استفاده از سویچ‌های مختلف روش‌های استفاده از autofix دو روش مختلف برای استفاده از autofix داریم:\nfix fix-regex فرمان Fix هر چیزی که قانون پیدا کرده است را با مقدار این فرمان جایگزین میکنیم. بهترین کاندیدها برای این قابلیت، توابع یا رشته (string) های ناامنی هستند که باید با معادل امن جایگزین شوند. چند مثال با این دستور ببینیم.\nPython - sys.exit این مثال را از آموزش Semgrep در آدرس (https://semgrep.dev/s/R6g) قرض گرفته‌ام. در این قانون ما به دنبال تابع exit هستیم و می‌خواهیم آن را با sys.exit جایگزین کنیم. Semgrep تفاوت تابع exit با دیگر استفاده‌های این کلمه را در کُد می‌فهمد و می‎‌تواند راحت آن را جایگزین کنید. بعد از اجرای قانون در وب‌سایت بالا می بینید که دکمه Apply Fix فعال شده و می‌توانید به صورت خودکار کد برنامه را دستکاری کنید.\nتغییر اتوماتیک exit به sys.exit یکی از نکات جالب این است که می‌توانیم پارامتر تابع را توسط یک metavariable (در اینجا با نام X) در قانون ذخیره کنیم و در autofix استفاده کنیم. دیگر لازم نیست حتی نگران مقدار پارامتر باشیم.\nJava - CBC Padding Oracle برای این مثال، قانون cbc-padding-oracle زبان جاوا را از رجیستری Semgrep دستکاری کرده‌ام تا راحت‌تر خوانده شود.\n# java-cbc-padding-oracle/cbc-padding-oracle.yaml rules: - id: cbc-padding-oracle severity: WARNING message: Match found languages: - java pattern: $CIPHER.getInstance(\"=~/.*\\/CBC\\/PKCS5Padding/\") fix: $CIPHER.getInstance(\"AES/GCM/NoPadding\") این قانون به دنبال هر چیزی که شبیه object.getInstance(\"string\") باشد می‌گردد و در صورتی که رشته داخل شامل CBC/PKCS5Padding باشد، نتیجه را گزارش می‌دهد. این قانون از قابلیت قدیمی string matching استفاده می‌کند که دیگر پشتیبانی نمی‌شود. برای دست‌گرمی باید آن را با metavariable-regex جایگزین کنیم. این کار ساده است، اول یک metavariable به عنوان پارامتر تعریف می‌کنیم (در اینجا INS$) و بعد regex را روی آن اجرا می‌کنیم و نتیجه همان است:\nhttps://semgrep.dev/s/parsiya:java-cbc-padding-oracle-metavariable-regex # java-cbc-padding-oracle/cbc-padding-oracle-metavariable-regex.yaml rules: - id: cbc-padding-oracle-metavariable-regex message: Match found languages: - java severity: WARNING patterns: - pattern: $CIPHER.getInstance($INS) - metavariable-regex: metavariable: $INS regex: .*\\/CBC\\/PKCS5Padding fix: $CIPHER.getInstance(\"AES/GCM/NoPadding\") مقدار “محاسبه” قانون جدید در playground عدد بزرگتری بود و من خواستم آن را آزمایش کنم. قانون جدید خیلی پیچیده‌تر از قانون قدیمی نیست.\n$ multitime -q -n 50 ./cbc-padding-oracle.sh ===\u003e multitime results 1: -q ./cbc-padding-oracle.sh Mean Std.Dev. Min Median Max real 0.781 0.006 0.773 0.780 0.806 user 0.501 0.041 0.406 0.500 0.609 sys 0.256 0.044 0.172 0.258 0.359 $ multitime -q -n 50 ./cbc-padding-oracle-metavariable-regex.sh ===\u003e multitime results 1: -q ./cbc-padding-oracle-metavariable-regex.sh Mean Std.Dev. Min Median Max real 0.788 0.007 0.778 0.786 0.813 user 0.516 0.047 0.406 0.516 0.609 sys 0.247 0.048 0.156 0.250 0.359 این مقدار محاسبه و عددی که در playground نشان داده می‌شود بحثی است که بعدا باید به آن بپردازم. خلاصه بگم، معمولاً نباید نگران عملکرد قانون خود باشید. مقدار زیادی از وقت Semgrep صرف خواندن و پردازش فایل‌ها و سپس درست کردن Abstract Syntax Tree (AST) کُد می‌شود. خیلی regex های پیچیده ننویسید اما دیگر نگران ذره ذره مسائل هم نباشید. برای دیدن زمانی که صرف هر بخش شده از سوییچ time-- استفاده کنید.\nJava - HttpOnly Cookies می‌خواهیم چک کنیم که آیا کوکی ما دارای خصوصیت HttpOnly است و اگر نیست آن را درست کنیم. من قانون cookie-missing-httponly جاوا را خلاصه کرده‌ام:\n# java-httponly/httponly-practice.yaml rules: - id: cookie-missing-httponly message: Match found severity: WARNING languages: [java] patterns: - pattern-not-inside: $COOKIE.setValue(\"\"); ... - pattern-either: - pattern: $COOKIE.setHttpOnly(false); - patterns: - pattern-not-inside: $COOKIE.setHttpOnly(...); ... - pattern: $RESPONSE.addCookie($COOKIE); این قانون (https://semgrep.dev/s/parsiya:java-httponly-practice) چک می‌کند که آیا:\nما به صورت دستی مقدار HttpOnly را false کرده‌ایم. در این صورت باید مقدار false را به true تغییر دهیم. یک کوکی به response (پاسخ؟) اضافه کرده‌ایم ولی HttpOnly را سِت نکرده‌ایم. در این صورت باید مقدار HttpOnly را به true تغییر دهیم برای رفع این مشکل باید این قانون را به این دو بخش بشکانیم و دو قانون مجزا درست کنیم زیرا بخش fix برای همه قوانین اجرا می‌شود ولی ما دو نوع ترمیم مختلف داریم.\nترمیم HttpOnly اول در این ترمیم تنها باید مقدار false در ;COOKIE.setHttpOnly(false)$را با true جایگزین کنیم (برای تمرین از https://semgrep.dev/s/parsiya:java-httponly-practice-1 استفاده کنید):\n# java-httponly/httponly-practice-1.yaml rules: - id: cookie-missing-httponly-1 message: Match found severity: WARNING languages: [java] patterns: - pattern-not-inside: $COOKIE.setValue(\"\"); ... - pattern: $COOKIE.setHttpOnly(false); fix: $COOKIE.setHttpOnly(true); semgrep -c httponly-practice-1.yaml httponly.java ترمیم HttpOnly دوم در این بخش ما ;RESPONSE.addCookie($COOKIE)$ را می‌بینیم اما خبری از setHttpOnly نیست.باید آن را اضافه کنیم. این قانون (https://semgrep.dev/s/parsiya:java-httponly-practice-2) این کار را انجام می‌دهد اما کد اضافه شده “خوشگل” نیست (برای جاوا فاصله و غیره مهم نیستند و شاید شما بگویید که این قانون برای من کافی است زیرا ابزارهای دیگری دارید که اتوماتیک کُد شما را فُرمَت می‎‌کنند).\nکُدِ زشت ما می‌توانیم این مشکل را با فرمان fix-regex حل کنیم.\nفرمان fix-regex همانطور که دیدیم برای جابجایی‌های ساده (مثلا تغییر badFunc به goodFunc) فرمان fix کافی است. اما fix-regex به ما قدرت مانور بیشتری می‌دهد.\nhttps://semgrep.dev/docs/experiments/overview/#autofix-with-regular-expression-replacement این فرمان سه بخش دارد:\nبخش regex که regular expression (فارسیش واقعا چی میشه؟ اصلاً معادل داره؟) را روی بخشی از کد که توسط قانون پیدا شده است، اجرا می‌کند. بخش replacement: چیزی که باید با بخش بالا جایگزین شود. بخش count: تعداد جایگزینی‌ها. نکته: در حال حاضر (آوریل 2022) Semgrep از metavariable در fix-regex پشتیبانی نمی‌کند.\nبا استفاده از fix-regex می‌توانیم قانون قبلی را دوباره بنویسیم. برای این کار اول باید ببینیم که چه چیزی capture می‌شود. این قانون را می‌توانید در https://semgrep.dev/s/parsiya:java-httponly-fix-regex-practice اجرا کنید.\n# java-httponly/httponly-fix-regex-practice.yaml rules: - id: cookie-missing-httponly-fix-regex-practice message: Match found severity: WARNING languages: - java patterns: - pattern-not-inside: $COOKIE.setValue(\"\"); ... - pattern-not-inside: $COOKIE.setHttpOnly(...); ... - pattern: $RESPONSE.addCookie($COOKIE); fix-regex: regex: (.*) replacement: //\\1 نتیجه اجرای قانون بالا در جواب، //را دو بار می‌بینیم. چون regex ما greedy (حریص) است. برای این کار باید از فیلد count با مقدار یک استفاده کنیم که فقط اولین جایگزینی انجام شود.\nاجرای قانون با count برابر یک ولی هنوز کُدِ خوشگل نداریم. برای این کار در بخش regex باید فاصله بین ابتدای خط تا اول کُد را capture کنیم. بعد در بخش replacement اول فاصله را جایگزین کنیم (1\\) و بعد // و در انتها خود کُد (2\\).\nfix-regex: regex: (\\s*)(.*) replacement: \\1// \\2 count: 1 حالا باید در خط جدید، کُدِ درست را وارد کنیم. اگر می‌توانستیم از metavariable ها استفاده کنیم کار ما خیلی راحت‌تر بود اما ترمیم پایین درست اجرا نمی‌شود. این را در https://semgrep.dev/s/parsiya:java-httponly-fix-regex-practice-2 می‌توانید امتحان کنید.\n# java-httponly/httponly-fix-regex-practice-2.yaml fix-regex: regex: (\\s*)(.*) replacement: | \\1$COOKIE.setHttpOnly(true); \\1\\2 count: 1 مقدار COOKIE$ در ترمیم جایگزین نشده است برای این کار باید از قانون زیر استفاده کنیم (واقعا حوصله توضیح دوباره آن را ندارم 😅):\n# java-httponly/httponly-fix-regex-practice-final.yaml rules: - id: cookie-missing-httponly-fix-regex-practice-final message: Match found severity: WARNING languages: - java patterns: - pattern-not-inside: $COOKIE.setValue(\"\"); ... - pattern-not-inside: $COOKIE.setHttpOnly(...); ... - pattern: $RESPONSE.addCookie($COOKIE); fix-regex: regex: (\\s*)(.*addCookie\\((.*)\\).*) replacement: | \\1\\3.setHttpOnly(true); \\1\\2 count: 1 بقیه بلاگ دیگر چیز جدیدی به شما یاد نمی‎‌دهد. اما می‌توانید در بلاگ انگلیسی بخوانید.\nچه یاد گرفتم؟ قابلیت ترمیم خودکار Semgrep بسیار جالب است. من از آن برای اضافه کردن comment به کد استفاده می‌کنم تا هنگام مرور آن بدانم هر بخش چه مشکلی دارد.\n","wordCount":"1401","inLanguage":"fa","datePublished":"2022-04-23T11:40:33-07:00","dateModified":"2022-04-23T11:40:33-07:00","author":{"@type":"Person","name":"پارسیا"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parsiya.github.io/parsiya.fa/post/2022/semgrep-autofix/"},"publisher":{"@type":"Organization","name":"امنیت و غیره به فارسی","logo":{"@type":"ImageObject","url":"https://parsiya.github.io/parsiya.fa/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://parsiya.github.io/parsiya.fa/ accesskey=h title="امنیت و غیره به فارسی (Alt + H)">امنیت و غیره به فارسی</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parsiya.github.io/parsiya.fa/>Home</a>&nbsp;»&nbsp;<a href=https://parsiya.github.io/parsiya.fa/post/>Posts</a></div><h1 class=post-title>قابلیت ترمیم خودکار Semgrep</h1><div class=post-meta>April 23, 2022&nbsp;·&nbsp;پارسیا</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>فهرست مطالب</div></summary><div class=inner><ul><li><a href=#%d9%be%db%8c%d8%b4%d9%86%db%8c%d8%a7%d8%b2%d9%87%d8%a7%db%8c-%d8%a7%db%8c%d9%86-%d8%a8%d9%84%d8%a7%da%af aria-label="پیش‌نیازهای این بلاگ">پیش‌نیازهای این بلاگ</a></li><li><a href=#%d8%a7%d8%ac%d8%b1%d8%a7%db%8c-%d9%82%d9%88%d8%a7%d9%86%db%8c%d9%86 aria-label="اجرای قوانین">اجرای قوانین</a></li><li><a href=#%d8%b1%d9%88%d8%b4%d9%87%d8%a7%db%8c-%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-autofix aria-label="روش‌های استفاده از autofix">روش‌های استفاده از autofix</a><ul><li><a href=#%d9%81%d8%b1%d9%85%d8%a7%d9%86-fix aria-label="فرمان Fix">فرمان Fix</a><ul><li><a href=#python---sysexit aria-label="Python - sys.exit">Python - sys.exit</a></li><li><a href=#java---cbc-padding-oracle aria-label="Java - CBC Padding Oracle">Java - CBC Padding Oracle</a></li><li><a href=#java---httponly-cookies aria-label="Java - HttpOnly Cookies">Java - HttpOnly Cookies</a><ul><li><a href=#%d8%aa%d8%b1%d9%85%db%8c%d9%85-httponly-%d8%a7%d9%88%d9%84 aria-label="ترمیم HttpOnly اول">ترمیم HttpOnly اول</a></li><li><a href=#%d8%aa%d8%b1%d9%85%db%8c%d9%85-httponly-%d8%af%d9%88%d9%85 aria-label="ترمیم HttpOnly دوم">ترمیم HttpOnly دوم</a></li></ul></li></ul></li><li><a href=#%d9%81%d8%b1%d9%85%d8%a7%d9%86-fix-regex aria-label="فرمان fix-regex">فرمان fix-regex</a></li></ul></li><li><a href=#%da%86%d9%87-%db%8c%d8%a7%d8%af-%da%af%d8%b1%d9%81%d8%aa%d9%85 aria-label="چه یاد گرفتم؟">چه یاد گرفتم؟</a></li></ul></div></details></div><div class=post-content><p>در این نوشتار می‌خواهم در مورد قابلیت ترمیمِ خودکار (<a href=https://semgrep.dev/docs/experiments/overview/#autofix>autofix</a>) کُد Semgrep صحبت کنم. این قابلیت آزمایشی به ما امکان می‌دهد که بعد از یافتن نتایج در فایلهای منبع، آنها را به صورت اتوماتیک دستکاری کنیم.</p><p>اگر علاقه به خواندن نسخه انگلیسی دارید:</p><ul><li><a href=https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/>https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/</a></li></ul><p>همه نمونه‌ها در Semgrep playground هستند ولی می‌توانید آنها را آفلاین نیز اجرا کنید:</p><ul><li><a href=https://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix>https://github.com/parsiya/Parsia-Code/tree/master/semgrep-autofix</a></li></ul><h1 id=پیشنیازهای-این-بلاگ>پیش‌نیازهای این بلاگ<a hidden class=anchor aria-hidden=true href=#پیشنیازهای-این-بلاگ>#</a></h1><p>برای استفاده بهینه از این بلاگ، بهتر است این موارد را بدانید:</p><ul><li>استفاده از Semgrep و نوشتن rule (قانون؟). <a href=/parsiya.fa/post/2021/semgrep-1/>چرا از Semgrep برای Static Analysis استفاده کنیم؟</a> را بخوانید.</li><li>آشنایی سَرسَری با خواندن کدُ Java، Python و Go.</li><li>آشنایی مختصر با بعضی مفاهیم امنیت مانند HttpOnly و XSS.</li></ul><p>نکته: ترمیمِ خودکار، یکی از <a href=https://semgrep.dev/docs/experiments/overview/>قابلیت‌های آزمایشی Semgrep</a> است. در زمان نگارش (آوریل 2022 برای نسخه فارسی و اکتبر 2021 برای نسخه انگلیسی) همه مثال‌ها درست هستند. اگر از آینده میایید، شاید بعضی چیزها متفاوت باشند.</p><h1 id=اجرای-قوانین>اجرای قوانین<a hidden class=anchor aria-hidden=true href=#اجرای-قوانین>#</a></h1><p>برای اجرا و تست قوانین دو راه داریم:</p><ol><li>استفاده از Semgrep playground در آدرس <a href=https://semgrep.dev/playground>https://semgrep.dev/playground</a>. من بیشتر از این روش استفاده می‌کنم چون راحت و سریع می‏‌توانم قانون را عوض کنم و نتیجه را ببینم.</li><li>اجرا در خطِ فرمان (ترجمه فارسی command line).</li></ol><p>بعد از نوشتن یک قانون می‌توانید درستی ساختار فایل yaml آن را تست کنید:</p><pre tabindex=0><code>semgrep-crule1.yaml--validate 
</code></pre><p>اگر یک قانون دارای بخش autofix باشد، هنگام اجرا فایل اصلی دستکاری نمی‌شود ولی می‌توانید تغییرات را ببینید. برای تغییر فایل اصلی از سویچ <code>autofix--</code> استفاده کنید. برای مشاهده تغییرات بدون تغییر فایل اصلی از سویچ <code>dry-run--</code> استفاده کنید (حضور همزمان autofix و dry-run معادل نبودِ autofix است یعنی تغییرات فقط نشان داده می‌شوند):</p><pre tabindex=0><code>semgrep -c rule1.yaml example.java --autofix --dryrun 
</code></pre><figure><img loading=lazy src=00-autofix-dryrun.png><figcaption>استفاده از سویچ‌های مختلف</figcaption></figure><h1 id=روشهای-استفاده-از-autofix>روش‌های استفاده از autofix<a hidden class=anchor aria-hidden=true href=#روشهای-استفاده-از-autofix>#</a></h1><p>دو روش مختلف برای استفاده از autofix داریم:</p><ol><li>fix</li><li>fix-regex</li></ol><h2 id=فرمان-fix>فرمان Fix<a hidden class=anchor aria-hidden=true href=#فرمان-fix>#</a></h2><p>هر چیزی که قانون پیدا کرده است را با مقدار این فرمان جایگزین میکنیم. بهترین کاندیدها برای این قابلیت، توابع یا رشته (string) های ناامنی هستند که باید با معادل امن جایگزین شوند. چند مثال با این دستور ببینیم.</p><h3 id=python---sysexit>Python - sys.exit<a hidden class=anchor aria-hidden=true href=#python---sysexit>#</a></h3><p>این مثال را از آموزش Semgrep در آدرس (<a href=https://semgrep.dev/s/R6g>https://semgrep.dev/s/R6g</a>) قرض گرفته‌ام. در این قانون ما به دنبال تابع exit هستیم و می‌خواهیم آن را با sys.exit جایگزین کنیم. Semgrep تفاوت تابع exit با دیگر استفاده‌های این کلمه را در کُد می‌فهمد و می‎‌تواند راحت آن را جایگزین کنید. بعد از اجرای قانون در وب‌سایت بالا می بینید که دکمه Apply Fix فعال شده و می‌توانید به صورت خودکار کد برنامه را دستکاری کنید.</p><figure><img loading=lazy src=01-sys-exit.png><figcaption>تغییر اتوماتیک exit به sys.exit</figcaption></figure><p>یکی از نکات جالب این است که می‌توانیم پارامتر تابع را توسط یک metavariable (در اینجا با نام X) در قانون ذخیره کنیم و در autofix استفاده کنیم. دیگر لازم نیست حتی نگران مقدار پارامتر باشیم.</p><h3 id=java---cbc-padding-oracle>Java - CBC Padding Oracle<a hidden class=anchor aria-hidden=true href=#java---cbc-padding-oracle>#</a></h3><p>برای این مثال، قانون cbc-padding-oracle زبان جاوا را از رجیستری Semgrep دستکاری کرده‌ام تا راحت‌تر خوانده شود.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># java-cbc-padding-oracle/cbc-padding-oracle.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>cbc-padding-oracle</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>WARNING</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>message</span>: <span style=color:#ae81ff>Match found</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>languages</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>java</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>pattern</span>: <span style=color:#ae81ff>$CIPHER.getInstance(&#34;=~/.*\/CBC\/PKCS5Padding/&#34;)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fix</span>: <span style=color:#ae81ff>$CIPHER.getInstance(&#34;AES/GCM/NoPadding&#34;)</span>
</span></span></code></pre></div><p>این قانون به دنبال هر چیزی که شبیه <code>object.getInstance("string")</code> باشد می‌گردد و در صورتی که رشته داخل شامل <code>CBC/PKCS5Padding</code> باشد، نتیجه را گزارش می‌دهد. این قانون از قابلیت قدیمی <a href=https://semgrep.dev/docs/writing-rules/pattern-syntax/#string-matching>string matching</a> استفاده می‌کند که دیگر پشتیبانی نمی‌شود. برای دست‌گرمی باید آن را با <a href=https://semgrep.dev/docs/writing-rules/rule-syntax/#metavariable-regex>metavariable-regex</a> جایگزین کنیم. این کار ساده است، اول یک metavariable به عنوان پارامتر تعریف می‌کنیم (در اینجا <code>INS$</code>) و بعد regex را روی آن اجرا می‌کنیم و نتیجه همان است:</p><ul><li><a href=https://semgrep.dev/s/parsiya:java-cbc-padding-oracle-metavariable-regex>https://semgrep.dev/s/parsiya:java-cbc-padding-oracle-metavariable-regex</a></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># java-cbc-padding-oracle/cbc-padding-oracle-metavariable-regex.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>cbc-padding-oracle-metavariable-regex</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>message</span>: <span style=color:#ae81ff>Match found</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>languages</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>java</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>WARNING</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>patterns</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern</span>: <span style=color:#ae81ff>$CIPHER.getInstance($INS)</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>metavariable-regex</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>metavariable</span>: <span style=color:#ae81ff>$INS</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>regex</span>: <span style=color:#ae81ff>.*\/CBC\/PKCS5Padding</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fix</span>: <span style=color:#ae81ff>$CIPHER.getInstance(&#34;AES/GCM/NoPadding&#34;)</span>
</span></span></code></pre></div><p>مقدار &ldquo;محاسبه&rdquo; قانون جدید در playground عدد بزرگتری بود و من خواستم آن را آزمایش کنم. قانون جدید خیلی پیچیده‌تر از قانون قدیمی نیست.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>$ multitime -q -n 50 ./cbc-padding-oracle.sh</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>===&gt; multitime results</span>
</span></span><span style=display:flex><span><span style=color:#f92672>1</span>: -<span style=color:#ae81ff>q ./cbc-padding-oracle.sh</span>
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>Mean        Std.Dev.    Min         Median      Max</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>real        0.781       0.006       0.773       0.780       0.806</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>user        0.501       0.041       0.406       0.500       0.609</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>sys         0.256       0.044       0.172       0.258       0.359</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>$ multitime -q -n 50 ./cbc-padding-oracle-metavariable-regex.sh</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>===&gt; multitime results</span>
</span></span><span style=display:flex><span><span style=color:#f92672>1</span>: -<span style=color:#ae81ff>q ./cbc-padding-oracle-metavariable-regex.sh</span>
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>Mean        Std.Dev.    Min         Median      Max</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>real        0.788       0.007       0.778       0.786       0.813</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>user        0.516       0.047       0.406       0.516       0.609</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>sys         0.247       0.048       0.156       0.250       0.359</span>
</span></span></code></pre></div><p>این مقدار محاسبه و عددی که در playground نشان داده می‌شود بحثی است که بعدا باید به آن بپردازم. خلاصه بگم، معمولاً نباید نگران عملکرد قانون خود باشید. مقدار زیادی از وقت Semgrep صرف خواندن و پردازش فایل‌ها و سپس درست کردن Abstract Syntax Tree (AST) کُد می‌شود. خیلی regex های پیچیده ننویسید اما دیگر نگران ذره ذره مسائل هم نباشید. برای دیدن زمانی که صرف هر بخش شده از سوییچ <code>time--</code> استفاده کنید.</p><h3 id=java---httponly-cookies>Java - HttpOnly Cookies<a hidden class=anchor aria-hidden=true href=#java---httponly-cookies>#</a></h3><p>می‌خواهیم چک کنیم که آیا کوکی ما دارای خصوصیت <code>HttpOnly</code> است و اگر نیست آن را درست کنیم. من قانون <a href=https://github.com/returntocorp/semgrep-rules/blob/develop/java/lang/security/audit/cookie-missing-httponly.yaml>cookie-missing-httponly</a> جاوا را خلاصه کرده‌ام:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># java-httponly/httponly-practice.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>id</span>: <span style=color:#ae81ff>cookie-missing-httponly</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>message</span>: <span style=color:#ae81ff>Match found</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>WARNING</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>languages</span>: [<span style=color:#ae81ff>java]</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>patterns</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>pattern-not-inside</span>: <span style=color:#ae81ff>$COOKIE.setValue(&#34;&#34;); ...</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>pattern-either</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>pattern</span>: <span style=color:#ae81ff>$COOKIE.setHttpOnly(false);</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>patterns</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern-not-inside</span>: <span style=color:#ae81ff>$COOKIE.setHttpOnly(...); ...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern</span>: <span style=color:#ae81ff>$RESPONSE.addCookie($COOKIE);</span>
</span></span></code></pre></div><p>این قانون (<a href=https://semgrep.dev/s/parsiya:java-httponly-practice>https://semgrep.dev/s/parsiya:java-httponly-practice</a>) چک می‌کند که آیا:</p><ol><li>ما به صورت دستی مقدار HttpOnly را false کرده‌ایم. در این صورت باید مقدار false را به true تغییر دهیم.</li><li>یک کوکی به response (پاسخ؟) اضافه کرده‌ایم ولی HttpOnly را سِت نکرده‌ایم. در این صورت باید مقدار HttpOnly را به true تغییر دهیم</li></ol><p>برای رفع این مشکل باید این قانون را به این دو بخش بشکانیم و دو قانون مجزا درست کنیم زیرا بخش fix برای همه قوانین اجرا می‌شود ولی ما دو نوع ترمیم مختلف داریم.</p><h4 id=ترمیم-httponly-اول>ترمیم HttpOnly اول<a hidden class=anchor aria-hidden=true href=#ترمیم-httponly-اول>#</a></h4><p>در این ترمیم تنها باید مقدار false در ;COOKIE.setHttpOnly(false)$را با true جایگزین کنیم (برای تمرین از <a href=https://semgrep.dev/s/parsiya:java-httponly-practice-1>https://semgrep.dev/s/parsiya:java-httponly-practice-1</a> استفاده کنید):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># java-httponly/httponly-practice-1.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>id</span>: <span style=color:#ae81ff>cookie-missing-httponly-1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>message</span>: <span style=color:#ae81ff>Match found</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>WARNING</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>languages</span>: [<span style=color:#ae81ff>java]</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>patterns</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>pattern-not-inside</span>: <span style=color:#ae81ff>$COOKIE.setValue(&#34;&#34;); ...</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>pattern</span>: <span style=color:#ae81ff>$COOKIE.setHttpOnly(false);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>fix</span>: <span style=color:#ae81ff>$COOKIE.setHttpOnly(true);</span>
</span></span></code></pre></div><figure><img loading=lazy src=02-httponly-1.png><figcaption>semgrep -c httponly-practice-1.yaml httponly.java</figcaption></figure><h4 id=ترمیم-httponly-دوم>ترمیم HttpOnly دوم<a hidden class=anchor aria-hidden=true href=#ترمیم-httponly-دوم>#</a></h4><p>در این بخش ما <code>;RESPONSE.addCookie($COOKIE)$</code> را می‌بینیم اما خبری از <code>setHttpOnly</code> نیست.باید آن را اضافه کنیم. این قانون (<a href=https://semgrep.dev/s/parsiya:java-httponly-practice-2>https://semgrep.dev/s/parsiya:java-httponly-practice-2</a>) این کار را انجام می‌دهد اما کد اضافه شده &ldquo;خوشگل&rdquo; نیست (برای جاوا فاصله و غیره مهم نیستند و شاید شما بگویید که این قانون برای من کافی است زیرا ابزارهای دیگری دارید که اتوماتیک کُد شما را فُرمَت می‎‌کنند).</p><figure><img loading=lazy src=03-httponly-2.png><figcaption>کُدِ زشت</figcaption></figure><p>ما می‌توانیم این مشکل را با فرمان <code>fix-regex</code> حل کنیم.</p><h2 id=فرمان-fix-regex>فرمان fix-regex<a hidden class=anchor aria-hidden=true href=#فرمان-fix-regex>#</a></h2><p>همانطور که دیدیم برای جابجایی‌های ساده (مثلا تغییر <code>badFunc</code> به <code>goodFunc</code>) فرمان fix کافی است. اما fix-regex به ما قدرت مانور بیشتری می‌دهد.</p><ul><li><a href=https://semgrep.dev/docs/experiments/overview/#autofix-with-regular-expression-replacement>https://semgrep.dev/docs/experiments/overview/#autofix-with-regular-expression-replacement</a></li></ul><p>این فرمان سه بخش دارد:</p><ol><li>بخش regex که regular expression (فارسیش واقعا چی میشه؟ اصلاً معادل داره؟) را روی بخشی از کد که توسط قانون پیدا شده است، اجرا می‌کند.</li><li>بخش replacement: چیزی که باید با بخش بالا جایگزین شود.</li><li>بخش count: تعداد جایگزینی‌ها.</li></ol><p><em>نکته: در حال حاضر (آوریل 2022) Semgrep از metavariable در fix-regex پشتیبانی نمی‌کند.</em></p><p>با استفاده از fix-regex می‌توانیم قانون قبلی را دوباره بنویسیم. برای این کار اول باید ببینیم که چه چیزی capture می‌شود. این قانون را می‌توانید در <a href=https://semgrep.dev/s/parsiya:java-httponly-fix-regex-practice>https://semgrep.dev/s/parsiya:java-httponly-fix-regex-practice</a> اجرا کنید.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># java-httponly/httponly-fix-regex-practice.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>cookie-missing-httponly-fix-regex-practice</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>message</span>: <span style=color:#ae81ff>Match found</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>WARNING</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>languages</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>java</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>patterns</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern-not-inside</span>: <span style=color:#ae81ff>$COOKIE.setValue(&#34;&#34;); ...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern-not-inside</span>: <span style=color:#ae81ff>$COOKIE.setHttpOnly(...); ...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern</span>: <span style=color:#ae81ff>$RESPONSE.addCookie($COOKIE);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fix-regex</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>regex</span>: <span style=color:#ae81ff>(.*)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>replacement</span>: <span style=color:#ae81ff>//\1</span>
</span></span></code></pre></div><figure><img loading=lazy src=04-httponly-fix-regex-1.png><figcaption>نتیجه اجرای قانون بالا</figcaption></figure><p>در جواب، <code>//</code>را دو بار می‌بینیم. چون regex ما greedy (حریص) است. برای این کار باید از فیلد <code>count</code> با مقدار یک استفاده کنیم که فقط اولین جایگزینی انجام شود.</p><figure><img loading=lazy src=05-httponly-fix-regex-2.png><figcaption>اجرای قانون با count برابر یک</figcaption></figure><p>ولی هنوز کُدِ خوشگل نداریم. برای این کار در بخش regex باید فاصله بین ابتدای خط تا اول کُد را capture کنیم. بعد در بخش replacement اول فاصله را جایگزین کنیم (<code>1\</code>) و بعد <code>//</code> و در انتها خود کُد (<code>2\</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>    <span style=color:#f92672>fix-regex</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>regex</span>: <span style=color:#ae81ff>(\s*)(.*)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>replacement</span>: <span style=color:#ae81ff>\1// \2</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>count</span>: <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><figure><img loading=lazy src=06-httponly-fix-regex-3.png></figure><p>حالا باید در خط جدید، کُدِ درست را وارد کنیم. اگر می‌توانستیم از metavariable ها استفاده کنیم کار ما خیلی راحت‌تر بود اما ترمیم پایین درست اجرا نمی‌شود. این را در <a href=https://semgrep.dev/s/parsiya:java-httponly-fix-regex-practice-2>https://semgrep.dev/s/parsiya:java-httponly-fix-regex-practice-2</a> می‌توانید امتحان کنید.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># java-httponly/httponly-fix-regex-practice-2.yaml</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fix-regex</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>regex</span>: <span style=color:#ae81ff>(\s*)(.*)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>replacement</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        \1$COOKIE.setHttpOnly(true);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        \1\2</span>        
</span></span><span style=display:flex><span>      <span style=color:#f92672>count</span>: <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><figure><img loading=lazy src=07-httponly-fix-regex-4.png><figcaption>مقدار COOKIE$ در ترمیم جایگزین نشده است</figcaption></figure><p>برای این کار باید از <a href=https://semgrep.dev/s/parsiya:java-httponly-fix-regex-practice-2>قانون زیر</a> استفاده کنیم (واقعا حوصله توضیح دوباره آن را ندارم 😅):</p><figure><img loading=lazy src=08-httponly-fix-regex-final.png></figure><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># java-httponly/httponly-fix-regex-practice-final.yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>rules</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>cookie-missing-httponly-fix-regex-practice-final</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>message</span>: <span style=color:#ae81ff>Match found</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>WARNING</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>languages</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>java</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>patterns</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern-not-inside</span>: <span style=color:#ae81ff>$COOKIE.setValue(&#34;&#34;); ...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern-not-inside</span>: <span style=color:#ae81ff>$COOKIE.setHttpOnly(...); ...</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>pattern</span>: <span style=color:#ae81ff>$RESPONSE.addCookie($COOKIE);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>fix-regex</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>regex</span>: <span style=color:#ae81ff>(\s*)(.*addCookie\((.*)\).*)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>replacement</span>: |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        \1\3.setHttpOnly(true);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        \1\2</span>        
</span></span><span style=display:flex><span>      <span style=color:#f92672>count</span>: <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>بقیه بلاگ دیگر چیز جدیدی به شما یاد نمی‎‌دهد. اما می‌توانید در <a href=https://parsiya.net/blog/2021-10-25-a-hands-on-intro-to-semgreps-autofix/>بلاگ انگلیسی</a> بخوانید.</p><h1 id=چه-یاد-گرفتم>چه یاد گرفتم؟<a hidden class=anchor aria-hidden=true href=#چه-یاد-گرفتم>#</a></h1><p>قابلیت ترمیم خودکار Semgrep بسیار جالب است. من از آن برای اضافه کردن comment به کد استفاده می‌کنم تا هنگام مرور آن بدانم هر بخش چه مشکلی دارد.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>تحت مجوز <a href=https://creativecommons.org/licenses/by-nc/4.0/>کریتیو کامنز اختیار-غیرتجاری 4.0 بین‌المللی</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/parsiya.fa/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>
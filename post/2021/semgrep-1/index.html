<!doctype html><html lang=fa dir=rtl><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>چرا از Semgrep برای Static Analysis استفاده کنیم؟ | امنیت و غیره به فارسی</title><meta name=keywords content><meta name=description content="در static analysis ما برنامه را اجرا نمی‌کنیم و معمولاً فقط کد (یا کد decompile یا disassemble شده) آن را بررسی می‌کنیم. توضیح این روش از حوصله این مقاله خارج است (خودمونیش این میشه که گوگل کنید).
چرا static analysis؟ من یک مهندس امنیت محصول (ترجمه product security engineer) هستم و معمولا به کد محصولات دسترسی دارم. بررسی کد یکی از مهمترین بخشهای کار من است. محصولات نرم‌افزاری مدرن (و به خصوص بازیهای کامپیوتری) ملغمه ای از چند هزار کتابخانه و فریمورک هستند و بررسی دستی کد آنها غیرممکن است."><meta name=author content="پارسیا"><link rel=canonical href=https://parsiya.github.io/parsiya.fa/post/2021/semgrep-1/><link href=/parsiya.fa/assets/css/stylesheet.min.d08f6c302eba3eaecd589684c093cecdfe7dfb8745a207401bd0583d3bb31837.css integrity="sha256-0I9sMC66Pq7NWJaEwJPOzf59+4dFogdAG9BYPTuzGDc=" rel="preload stylesheet" as=style><link rel=icon href=https://parsiya.github.io/parsiya.fa/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://parsiya.github.io/parsiya.fa/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://parsiya.github.io/parsiya.fa/favicon-32x32.png><link rel=apple-touch-icon href=https://parsiya.github.io/parsiya.fa/apple-touch-icon.png><link rel=mask-icon href=https://parsiya.github.io/parsiya.fa/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.84.4"><link rel=stylesheet href=https://parsiya.github.io/parsiya.fa/css/vazir-font.css><link rel=stylesheet href=https://parsiya.github.io/parsiya.fa/css/custom.css><meta property="og:title" content="چرا از Semgrep برای Static Analysis استفاده کنیم؟"><meta property="og:description" content="در static analysis ما برنامه را اجرا نمی‌کنیم و معمولاً فقط کد (یا کد decompile یا disassemble شده) آن را بررسی می‌کنیم. توضیح این روش از حوصله این مقاله خارج است (خودمونیش این میشه که گوگل کنید).
چرا static analysis؟ من یک مهندس امنیت محصول (ترجمه product security engineer) هستم و معمولا به کد محصولات دسترسی دارم. بررسی کد یکی از مهمترین بخشهای کار من است. محصولات نرم‌افزاری مدرن (و به خصوص بازیهای کامپیوتری) ملغمه ای از چند هزار کتابخانه و فریمورک هستند و بررسی دستی کد آنها غیرممکن است."><meta property="og:type" content="article"><meta property="og:url" content="https://parsiya.github.io/parsiya.fa/post/2021/semgrep-1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-07-03T11:40:33-07:00"><meta property="article:modified_time" content="2021-07-03T11:40:33-07:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="چرا از Semgrep برای Static Analysis استفاده کنیم؟"><meta name=twitter:description content="در static analysis ما برنامه را اجرا نمی‌کنیم و معمولاً فقط کد (یا کد decompile یا disassemble شده) آن را بررسی می‌کنیم. توضیح این روش از حوصله این مقاله خارج است (خودمونیش این میشه که گوگل کنید).
چرا static analysis؟ من یک مهندس امنیت محصول (ترجمه product security engineer) هستم و معمولا به کد محصولات دسترسی دارم. بررسی کد یکی از مهمترین بخشهای کار من است. محصولات نرم‌افزاری مدرن (و به خصوص بازیهای کامپیوتری) ملغمه ای از چند هزار کتابخانه و فریمورک هستند و بررسی دستی کد آنها غیرممکن است."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parsiya.github.io/parsiya.fa/post/"},{"@type":"ListItem","position":2,"name":"چرا از Semgrep برای Static Analysis استفاده کنیم؟","item":"https://parsiya.github.io/parsiya.fa/post/2021/semgrep-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"چرا از Semgrep برای Static Analysis استفاده کنیم؟","name":"چرا از Semgrep برای Static Analysis استفاده کنیم؟","description":"در static analysis ما برنامه را اجرا نمی‌کنیم و معمولاً فقط کد (یا کد decompile یا disassemble شده) آن را بررسی می‌کنیم. توضیح این روش از حوصله این مقاله خارج است (خودمونیش این میشه که گوگل کنید).\nچرا static analysis؟ من یک مهندس امنیت محصول (ترجمه product security engineer) هستم و معمولا به کد محصولات دسترسی دارم. بررسی کد یکی از مهمترین بخشهای کار من است. محصولات نرم‌افزاری مدرن (و به خصوص بازیهای کامپیوتری) ملغمه ای از چند هزار کتابخانه و فریمورک هستند و بررسی دستی کد آنها غیرممکن است.","keywords":[],"articleBody":"در static analysis ما برنامه را اجرا نمی‌کنیم و معمولاً فقط کد (یا کد decompile یا disassemble شده) آن را بررسی می‌کنیم. توضیح این روش از حوصله این مقاله خارج است (خودمونیش این میشه که گوگل کنید).\nچرا static analysis؟ من یک مهندس امنیت محصول (ترجمه product security engineer) هستم و معمولا به کد محصولات دسترسی دارم. بررسی کد یکی از مهمترین بخشهای کار من است. محصولات نرم‌افزاری مدرن (و به خصوص بازیهای کامپیوتری) ملغمه ای از چند هزار کتابخانه و فریمورک هستند و بررسی دستی کد آنها غیرممکن است. به عنوان مثال یک بازی کامپیوتری حداقل چندین میلیون خط کد دارد:\n کد client بازی که روی کامپیوتر و یا کنسول اجرا می‌شود (معمولاً ++C). کد سرورهای مختلف مانند login, lobby, matchmaking و غیره که می‌تواند به هر زبانی باشد. کد برنامه موبایل همراه بازی مانند FIFA 21 Mobile companion app. زبان برنامه نویسی معمولاً جاوا (اندروید) و swift (برای iOS) است. کد integration با سرویسهای دیگر مانند market place و یا Steam. کد زیرساخت ابری (منظور اینجا infrastructure-as-code مثل Terraform است که فارسیش نمی‌دونم چیِ).  برای بررسی این همه کد باید به چندین زبان برنامه‌نویسی و فریمورک عمومی و خصوصی (ترجمه آزاد proprietary) مختلف مسلط بود (که تقریبا امکان ندارد) و از ابزارهای مختلف استفاده کرد.\nاستفاده از grep مهمترین اسلحه من برای بررسی کد، grep است. معمولاً به دنبال کلمات کلیدی در کد می‌گردم تا قسمت‌های مهم را پیدا کنم. مثلاً grep -ir password در تمامی فایلهای دایرکتوری حاضر (و فرزندانش) به دنبال کلمه password (صرفنظر از حروف کوچک و بزرگ) می‌گردد.\nدر چند سال اخیر از برنامه ripgrep که با زبان برنامه‌نویسی Rust نوشته شده است، استفاده می‌کنم. به عنوان یک gopher سابق همیشه به شوخی می‌گویم که بالاخره Rust هم یک فایده‌ای داشت. تا یک سال قبل شاید 90 درصد باگ‌های امنیتی در کد را با grep پیدا کرده بودم. بعد از مدتی سروکله زدن با فریمورک‌ها و زبانهای برنامه‌نویسی مختلف لیستی از کلمات مهم درست می‌کنید و به دنبال آنها می‌گردید.\nنقطه ضعف grep بزرگترین مشکل grep برای تحلیل کد، ندانستن مفهوم کلمات است. grep برای جستجوی متن طراحی شده و برایش مهم نیست که این کلمه در آن زبان برنامه‌نویسی چه تایپی دارد (مثلاً تابع یا کامنت یا غیره). اگر به دنبال کلمه password در کد Go زیر بگردیم چهار نتیجه مختلف داریم:\n// nem.go package main func main() { // کلمه پسورد اینجا بخشی از کامنت است  // Hardcoded passwords are bad.  // کلمه پسورد در اینجا نام متغیر است  password := \"hunter2\" // کلمه پسورد در اینجا بخشی از یک استرینگ است  errorMsg := \"Incorrect password\" } // کلمه پسورد در اینجا بخشی از نامِ تابع است func validatePassword(p string) bool { // Do something  return true } فرض کنیم هدف من توابعی است که در نام خود کلمه پسورد را دارند. در اینجا با استفاده از grep باید چهار نتیجه را بررسی کنم تا به جواب برسم. شاید بگویید که این مشکلی نیست ولی، در یک برنامه واقعی با میلیونها خط کد، هر جستجو صدها نتیجه بی‌ربط (false positive) دارد.\nیک تکنیک من برای حل این مشکل جستجوی پرانتز به همراه نام تابع بود.\nاین تا حدی کمک می‌کند ولی مواردی که فاصله یا whitespace بین پرانتز و کلمه پسورد وجود دارد را پیدا نمی‌کند. می‌توانم با استفاده از regular expression جستجوی خود را بهتر کنم ولی در انتها راهی وجود ندارد که به grep بفهمانم که فقط به دنبال نام تابع بگردد.\nورود Semgrep وز آشنایی با Semgrep یکی از بهترین روزهای زندگی شغلی من بود. با استفاده از Semgrep می‌توانم چند پله بالاتر از grep عمل کنم و به برنامه بفهمانم که فقط در یک تایپ خاص به دنبال کلمات بگردد. نمی‌خواهم این پست را به “آموزش Semgrep” تبدیل کنم. برای این کار از https://semgrep.dev/learn شروع کنید. ولی، چند مثال کوتاه را توضیح می‌دهم.\nhttps://semgrep.dev/learn/2 می‌خواهیم در کد Python زیر همه مواردی که تابع logging.info با پارامتر تابع get_user را پیدا کنیم.\nimport logging as lg def get_user(uid): d = {1: \"harry\", 2: \"ron\", 3: \"hermione\"} return d[uid] # Match both of these using an ellipsis. logging.info(get_user(1) + \" logged in\") lg.info(get_user(2) + \" logged in\") اگر از grep استفاده کنیم:\nولی اینجا مورد اول پیدا شد و مورد دوم نه. چرا؟ چون grep نمی‌داند که lg در اینجا معادل logging است. با Semgrep این مشکل را نداریم چون می‌داند که اینجا lg و logging یکی هستند. … هم همان غیره خودمان است که با همه چیز match می‌شود (توضیح بیشترش را در خود آموزش بخوانید).\nhttps://semgrep.dev/learn/6 اینجا به بحث شیرین metavariable می‌رسیم که می‌تواند جایگزین هر آیتم باشند.اگر بخواهیم همه توابع را در Python پیدا کنیم:\ndef $FUNC(...): ... حالا می‌توانیم داخل این توابع جستجو کنیم. در اینجا فقط یک جستجوی ساده انجام می‌دهیم. می‌خواهیم که ببنیم آیا تابع با یک مِتُد از requests تمام می‌شود؟\nحالا فرض کنید بخواهیم یک rule برای امنیت بنویسیم. می‌خواهیم چک کنیم که آیا ورودی تابع در پارامترهای مِتُدِ requests وجود دارد؟ چرا این کار ناامن است؟ فرض می‌کنیم که ورودی تابع مستقیماً از ورودی کاربر است و اگر به کاربر اجازه دهیم تا هر url را دریافت کند ممکن است به مشکل SSRF بربخوریم. rule ما به این صورت است.\ndef $FUNC($USERINPUT): ... requests.$METHOD(...,$USERINPUT,...) در خط اول یک metavariable تعریف کرده‌ام که به جای ورودی تابع است. سپس، چک می‌کنیم که ورودی به مِتُد می‌رسد یا خیر. یک مِتُد امن هم به کد اضافه کرده‌ام که نباید در نتایج باشد.\nبا metavariable ها کارهای عجیب غریبی می‌توانیم انجام بدهیم. مشابه همین کاری که کردیم را در بخش 8 آموزش می‌بینیم.\nhttps://semgrep.dev/learn/8 اگر در Python یک فایل را برای خواندن باز کرده باشیم دیگر نباید به آن بنویسیم. در اینجا metavariable متغیر حاوی هَندِلِ فایل است. سپس می‌توانیم چک کنیم که آیا متد write را برای آن فراخوانی کرده‌ایم. پس rule ما این شکل می‌شود:\nhttps://semgrep.dev/learn/13 درس 13 جالب است. می‌توانیم توسط pattern-inside بخشهایی که می‌خواهیم را جدا کنیم و سپس داخل آنها را با pattern بگردیم. اینجا می‌خواهیم که داخل توابع این کُدِ Go:\n آیا پارامتر ورودی از نوع http.ResponseWriter هست؟ آیا مِتُدِ Write روی آن فراخوانی شده است؟  در ابتدا rule به این صورت است. اول همه توابع توسط pattern-inside انتخاب می‌شوند و بعد در داخل آنها به دنبال متد Write می‌گردد.\nباید pattern-inside را دستکاری کنیم تا تنها توابعی را پیدا کند که یکی از پارامترهای ورودیشان از نوع http.ResponseWriter است. با گذاشتن … قبل و بعد پارامتر به Semgrep می‌گوییم که این پارامتر می‌تواند هرجا باشد.\n- pattern-inside: |func $FUNC(..., $WRITER http.ResponseWriter, ...) { ... } حالا می‌توانیم توسط pattern چک کنیم که آیا مِتُدِ Write روی این ورودی فراخوانی شده یا خیر.\nحل مساله اول حتماً کل آموزش را تا انتها ادامه دهید ولی حل تک تک آنها در این پست فایده‌ای ندارد. بجای آن می‌خواهم مشکلی که در اول داشتیم را حل کنم. مشکل ما این بود که میخواستیم توابعی که در نام آنها کلمه password وجود دارد را پیدا کنیم. می‌توانید به صورت عملی راه‌حلهای خودتان را در این آدرس امتحان کنید https://semgrep.dev/s/WODo.\nدر مرحله اول یک pattern می‌نویسیم تا همه توابع را پیدا کند. این کار را قبلا انجام داده‌ایم و چیز عجیبی نیست.\nجواب جستجو هر دو تابع را پیدا کرد. دقت کنید که الان نام تابع در metavariable به نام FUNC ذخیره شده. حالا، می‌توانیم از قابلیت metavariable-regex استفاده کنیم و یک regex را روی آن اجرا کنیم.\nrules: - id: password-in-func-name languages: - go message: Find functions that have password in their name. patterns: - pattern: |func $FUNC(...) { ... } - metavariable-regex: metavariable: $FUNC regex: .*password.* severity: ERROR ولی باز هم کار نمی‌کند چون regex به صورت case-sensitive اجرا می‌شود. برای اجرای آن به صورت case-insensitive می‌توانیم از inline flag استفاده کنیم.\nregex: (?i).*password.* و جوابمان را گرفتیم.\nچی یاد گرفتیم؟ یاد گرفتیم که با استفاده از Semgrep راحت‌تر داخل کد جستجو کنیم. با Semgrep کارهای خیلی عجیب غریبی کرده‌ام که خودم هم باورم نمی‌شود. شما هم می‌توانید از این ابزار مجانی در کار خود استفاده کنید و به قولی sky is the limit.\nنقشه من برای بلاگ بعدی:\n چرا از Semgrep (مثلا به جای CodeQL) استفاده می‌کنم. چگونه از Semgrep در CI/CD استفاده می‌کنم.  ","wordCount":"1335","inLanguage":"fa","datePublished":"2021-07-03T11:40:33-07:00","dateModified":"2021-07-03T11:40:33-07:00","author":{"@type":"Person","name":"پارسیا"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parsiya.github.io/parsiya.fa/post/2021/semgrep-1/"},"publisher":{"@type":"Organization","name":"امنیت و غیره به فارسی","logo":{"@type":"ImageObject","url":"https://parsiya.github.io/parsiya.fa/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://parsiya.github.io/parsiya.fa/ accesskey=h title="امنیت و غیره به فارسی (Alt + H)">امنیت و غیره به فارسی</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parsiya.github.io/parsiya.fa/>Home</a>&nbsp;»&nbsp;<a href=https://parsiya.github.io/parsiya.fa/post/>Posts</a></div><h1 class=post-title>چرا از Semgrep برای Static Analysis استفاده کنیم؟</h1><div class=post-meta>July 3, 2021&nbsp;·&nbsp;پارسیا</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>فهرست مطالب</div></summary><div class=inner><ul><li><a href=#%da%86%d8%b1%d8%a7-static-analysis aria-label="چرا static analysis؟">چرا static analysis؟</a></li><li><a href=#%d8%a7%d8%b3%d8%aa%d9%81%d8%a7%d8%af%d9%87-%d8%a7%d8%b2-grep aria-label="استفاده از grep">استفاده از grep</a></li><li><a href=#%d9%86%d9%82%d8%b7%d9%87-%d8%b6%d8%b9%d9%81-grep aria-label="نقطه ضعف grep">نقطه ضعف grep</a></li><li><a href=#%d9%88%d8%b1%d9%88%d8%af-semgrep aria-label="ورود Semgrep">ورود Semgrep</a></li><li><a href=#httpssemgrepdevlearn2 aria-label=https://semgrep.dev/learn/2><a href=https://semgrep.dev/learn/2>https://semgrep.dev/learn/2</a></a></li><li><a href=#httpssemgrepdevlearn6 aria-label=https://semgrep.dev/learn/6><a href=https://semgrep.dev/learn/6>https://semgrep.dev/learn/6</a></a></li><li><a href=#httpssemgrepdevlearn8 aria-label=https://semgrep.dev/learn/8><a href=https://semgrep.dev/learn/8>https://semgrep.dev/learn/8</a></a></li><li><a href=#httpssemgrepdevlearn13 aria-label=https://semgrep.dev/learn/13><a href=https://semgrep.dev/learn/13>https://semgrep.dev/learn/13</a></a></li><li><a href=#%d8%ad%d9%84-%d9%85%d8%b3%d8%a7%d9%84%d9%87-%d8%a7%d9%88%d9%84 aria-label="حل مساله اول">حل مساله اول</a></li><li><a href=#%da%86%db%8c-%db%8c%d8%a7%d8%af-%da%af%d8%b1%d9%81%d8%aa%db%8c%d9%85 aria-label="چی یاد گرفتیم؟">چی یاد گرفتیم؟</a></li></ul></div></details></div><div class=post-content><p>در static analysis ما برنامه را اجرا نمی‌کنیم و معمولاً فقط کد (یا کد decompile یا disassemble شده) آن را بررسی می‌کنیم. توضیح این روش از حوصله این مقاله خارج است (خودمونیش این میشه که گوگل کنید).</p><h2 id=چرا-static-analysis>چرا static analysis؟<a hidden class=anchor aria-hidden=true href=#چرا-static-analysis>#</a></h2><p>من یک مهندس امنیت محصول (ترجمه product security engineer) هستم و معمولا به کد محصولات دسترسی دارم. بررسی کد یکی از مهمترین بخشهای کار من است. محصولات نرم‌افزاری مدرن (و به خصوص بازیهای کامپیوتری) ملغمه ای از چند هزار کتابخانه و فریمورک هستند و بررسی دستی کد آنها غیرممکن است. به عنوان مثال یک بازی کامپیوتری حداقل چندین میلیون خط کد دارد:</p><ol><li>کد client بازی که روی کامپیوتر و یا کنسول اجرا می‌شود (معمولاً ++C).</li><li>کد سرورهای مختلف مانند login, lobby, matchmaking و غیره که می‌تواند به هر زبانی باشد.</li><li>کد برنامه موبایل همراه بازی مانند FIFA 21 Mobile companion app. زبان برنامه نویسی معمولاً جاوا (اندروید) و swift (برای iOS) است.</li><li>کد integration با سرویسهای دیگر مانند market place و یا Steam.</li><li>کد زیرساخت ابری (منظور اینجا infrastructure-as-code مثل Terraform است که فارسیش نمی‌دونم چیِ).</li></ol><p>برای بررسی این همه کد باید به چندین زبان برنامه‌نویسی و فریمورک عمومی و خصوصی (ترجمه آزاد proprietary) مختلف مسلط بود (که تقریبا امکان ندارد) و از ابزارهای مختلف استفاده کرد.</p><h2 id=استفاده-از-grep>استفاده از grep<a hidden class=anchor aria-hidden=true href=#استفاده-از-grep>#</a></h2><p>مهمترین اسلحه من برای بررسی کد، <a href=https://man7.org/linux/man-pages/man1/grep.1.html>grep</a> است. معمولاً به دنبال کلمات کلیدی در کد می‌گردم تا قسمت‌های مهم را پیدا کنم. مثلاً <code>grep -ir password</code> در تمامی فایلهای دایرکتوری حاضر (و فرزندانش) به دنبال کلمه <code>password</code> (صرفنظر از حروف کوچک و بزرگ) می‌گردد.</p><p>در چند سال اخیر از برنامه <a href=https://github.com/BurntSushi/ripgrep>ripgrep</a> که با زبان برنامه‌نویسی Rust نوشته شده است، استفاده می‌کنم. به عنوان یک gopher سابق همیشه به شوخی می‌گویم که بالاخره Rust هم یک فایده‌ای داشت.
تا یک سال قبل شاید 90 درصد باگ‌های امنیتی در کد را با grep پیدا کرده بودم. بعد از مدتی سروکله زدن با فریمورک‌ها و زبانهای برنامه‌نویسی مختلف لیستی از کلمات مهم درست می‌کنید و به دنبال آنها می‌گردید.</p><h2 id=نقطه-ضعف-grep>نقطه ضعف grep<a hidden class=anchor aria-hidden=true href=#نقطه-ضعف-grep>#</a></h2><p>بزرگترین مشکل grep برای تحلیل کد، ندانستن مفهوم کلمات است. grep برای جستجوی متن طراحی شده و برایش مهم نیست که این کلمه در آن زبان برنامه‌نویسی چه تایپی دارد (مثلاً تابع یا کامنت یا غیره). اگر به دنبال کلمه password در کد Go زیر بگردیم چهار نتیجه مختلف داریم:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// nem.go
</span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#75715e>// کلمه پسورد اینجا بخشی از کامنت است
</span><span style=color:#75715e></span>    <span style=color:#75715e>// Hardcoded passwords are bad.
</span><span style=color:#75715e></span>
    <span style=color:#75715e>// کلمه پسورد در اینجا نام متغیر است
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>password</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;hunter2&#34;</span>

    <span style=color:#75715e>// کلمه پسورد در اینجا بخشی از یک استرینگ است
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>errorMsg</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;Incorrect password&#34;</span>
}

<span style=color:#75715e>// کلمه پسورد در اینجا بخشی از نامِ تابع است
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>validatePassword</span>(<span style=color:#a6e22e>p</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>bool</span> {
    <span style=color:#75715e>// Do something
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
}
</code></pre></div><p><img loading=lazy src=01-grep-password.png alt></p><p>فرض کنیم هدف من توابعی است که در نام خود کلمه پسورد را دارند. در اینجا با استفاده از grep باید چهار نتیجه را بررسی کنم تا به جواب برسم. شاید بگویید که این مشکلی نیست ولی، در یک برنامه واقعی با میلیونها خط کد، هر جستجو صدها نتیجه بی‌ربط (false positive) دارد.</p><p>یک تکنیک من برای حل این مشکل جستجوی پرانتز به همراه نام تابع بود.</p><p><img loading=lazy src=02-grep-password2.png alt></p><p>این تا حدی کمک می‌کند ولی مواردی که فاصله یا whitespace بین پرانتز و کلمه پسورد وجود دارد را پیدا نمی‌کند. می‌توانم با استفاده از regular expression جستجوی خود را بهتر کنم ولی در انتها راهی وجود ندارد که به grep بفهمانم که فقط به دنبال نام تابع بگردد.</p><h2 id=ورود-semgrep>ورود Semgrep<a hidden class=anchor aria-hidden=true href=#ورود-semgrep>#</a></h2><p>وز آشنایی با <a href=https://semgrep.dev/>Semgrep</a> یکی از بهترین روزهای زندگی شغلی من بود. با استفاده از Semgrep می‌توانم چند پله بالاتر از grep عمل کنم و به برنامه بفهمانم که فقط در یک تایپ خاص به دنبال کلمات بگردد. نمی‌خواهم این پست را به &ldquo;آموزش Semgrep&rdquo; تبدیل کنم. برای این کار از <a href=https://semgrep.dev/learn>https://semgrep.dev/learn</a> شروع کنید. ولی، چند مثال کوتاه را توضیح می‌دهم.</p><h2 id=httpssemgrepdevlearn2><a href=https://semgrep.dev/learn/2>https://semgrep.dev/learn/2</a><a hidden class=anchor aria-hidden=true href=#httpssemgrepdevlearn2>#</a></h2><p>می‌خواهیم در کد Python زیر همه مواردی که تابع <code>logging.info</code> با پارامتر تابع <code>get_user</code> را پیدا کنیم.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> logging <span style=color:#66d9ef>as</span> lg

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_user</span>(uid):
    d <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>: <span style=color:#e6db74>&#34;harry&#34;</span>, <span style=color:#ae81ff>2</span>: <span style=color:#e6db74>&#34;ron&#34;</span>, <span style=color:#ae81ff>3</span>: <span style=color:#e6db74>&#34;hermione&#34;</span>}
    <span style=color:#66d9ef>return</span> d[uid]

<span style=color:#75715e># Match both of these using an ellipsis.</span>
logging<span style=color:#f92672>.</span>info(get_user(<span style=color:#ae81ff>1</span>)
    <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; logged in&#34;</span>)
lg<span style=color:#f92672>.</span>info(get_user(<span style=color:#ae81ff>2</span>)
    <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; logged in&#34;</span>)
</code></pre></div><p>اگر از grep استفاده کنیم:</p><p><img loading=lazy src=03-grep-logging.png alt></p><p>ولی اینجا مورد اول پیدا شد و مورد دوم نه. چرا؟ چون grep نمی‌داند که <code>lg</code> در اینجا معادل <code>logging</code> است. با Semgrep این مشکل را نداریم چون می‌داند که اینجا lg و logging یکی هستند. &mldr; هم همان غیره خودمان است که با همه چیز match می‌شود (توضیح بیشترش را در خود آموزش بخوانید).</p><p><img loading=lazy src=04-semgrep-logging.png alt></p><h2 id=httpssemgrepdevlearn6><a href=https://semgrep.dev/learn/6>https://semgrep.dev/learn/6</a><a hidden class=anchor aria-hidden=true href=#httpssemgrepdevlearn6>#</a></h2><p>اینجا به بحث شیرین metavariable می‌رسیم که می‌تواند جایگزین هر آیتم باشند.اگر بخواهیم همه توابع را در Python پیدا کنیم:</p><pre><code>def $FUNC(...):
    ...
</code></pre><p><img loading=lazy src=05-semgrep-py-all-functions.png alt></p><p>حالا می‌توانیم داخل این توابع جستجو کنیم. در اینجا فقط یک جستجوی ساده انجام می‌دهیم. می‌خواهیم که ببنیم آیا تابع با یک مِتُد از requests تمام می‌شود؟</p><p><img loading=lazy src=06-semgrep-tut-6.png alt></p><p>حالا فرض کنید بخواهیم یک rule برای امنیت بنویسیم. می‌خواهیم چک کنیم که آیا ورودی تابع در پارامترهای مِتُدِ requests وجود دارد؟ چرا این کار ناامن است؟ فرض می‌کنیم که ورودی تابع مستقیماً از ورودی کاربر است و اگر به کاربر اجازه دهیم تا هر url را دریافت کند ممکن است به مشکل SSRF بربخوریم. rule ما به این صورت است.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#960050;background-color:#1e0010>$</span>FUNC(<span style=color:#960050;background-color:#1e0010>$</span>USERINPUT):
    <span style=color:#f92672>...</span>
    requests<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>$</span>METHOD(<span style=color:#f92672>...</span>,<span style=color:#960050;background-color:#1e0010>$</span>USERINPUT,<span style=color:#f92672>...</span>)
</code></pre></div><p>در خط اول یک metavariable تعریف کرده‌ام که به جای ورودی تابع است. سپس، چک می‌کنیم که ورودی به مِتُد می‌رسد یا خیر. یک مِتُد امن هم به کد اضافه کرده‌ام که نباید در نتایج باشد.</p><p><img loading=lazy src=07-userinput.png alt></p><p>با metavariable ها کارهای عجیب غریبی می‌توانیم انجام بدهیم. مشابه همین کاری که کردیم را در بخش 8 آموزش می‌بینیم.</p><h2 id=httpssemgrepdevlearn8><a href=https://semgrep.dev/learn/8>https://semgrep.dev/learn/8</a><a hidden class=anchor aria-hidden=true href=#httpssemgrepdevlearn8>#</a></h2><p>اگر در Python یک فایل را برای خواندن باز کرده باشیم دیگر نباید به آن بنویسیم. در اینجا metavariable متغیر حاوی هَندِلِ فایل است. سپس می‌توانیم چک کنیم که آیا متد write را برای آن فراخوانی کرده‌ایم. پس rule ما این شکل می‌شود:</p><p><img loading=lazy src=08-python-write-file.png alt></p><h2 id=httpssemgrepdevlearn13><a href=https://semgrep.dev/learn/13>https://semgrep.dev/learn/13</a><a hidden class=anchor aria-hidden=true href=#httpssemgrepdevlearn13>#</a></h2><p>درس 13 جالب است. می‌توانیم توسط <code>pattern-inside</code> بخشهایی که می‌خواهیم را جدا کنیم و سپس داخل آنها را با <code>pattern</code> بگردیم. اینجا می‌خواهیم که داخل توابع این کُدِ Go:</p><ol><li>آیا پارامتر ورودی از نوع http.ResponseWriter هست؟</li><li>آیا مِتُدِ Write روی آن فراخوانی شده است؟</li></ol><p>در ابتدا rule به این صورت است. اول همه توابع توسط <code>pattern-inside</code> انتخاب می‌شوند و بعد در داخل آنها به دنبال متد Write می‌گردد.</p><p><img loading=lazy src=09-pattern-inside-1.png alt></p><p>باید <code>pattern-inside</code> را دستکاری کنیم تا تنها توابعی را پیدا کند که یکی از پارامترهای ورودیشان از نوع <code>http.ResponseWriter</code> است. با گذاشتن &mldr; قبل و بعد پارامتر به Semgrep می‌گوییم که این پارامتر می‌تواند هرجا باشد.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:#f92672>pattern-inside</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>    func $FUNC(..., $WRITER http.ResponseWriter, ...) {
</span><span style=color:#e6db74>      ...
</span><span style=color:#e6db74>    }</span>    
</code></pre></div><p>حالا می‌توانیم توسط pattern چک کنیم که آیا مِتُدِ Write روی این ورودی فراخوانی شده یا خیر.</p><p><img loading=lazy src=10-pattern-inside-2.png alt></p><h2 id=حل-مساله-اول>حل مساله اول<a hidden class=anchor aria-hidden=true href=#حل-مساله-اول>#</a></h2><p>حتماً کل آموزش را تا انتها ادامه دهید ولی حل تک تک آنها در این پست فایده‌ای ندارد. بجای آن می‌خواهم مشکلی که در اول داشتیم را حل کنم. مشکل ما این بود که میخواستیم توابعی که در نام آنها کلمه password وجود دارد را پیدا کنیم. می‌توانید به صورت عملی راه‌حلهای خودتان را در این آدرس امتحان کنید <a href=https://semgrep.dev/s/WODo>https://semgrep.dev/s/WODo</a>.</p><p>در مرحله اول یک pattern می‌نویسیم تا همه توابع را پیدا کند. این کار را قبلا انجام داده‌ایم و چیز عجیبی نیست.</p><p><img loading=lazy src=11-password-match-1.png alt></p><p>جواب جستجو هر دو تابع را پیدا کرد. دقت کنید که الان نام تابع در metavariable به نام FUNC ذخیره شده. حالا، می‌توانیم از قابلیت metavariable-regex استفاده کنیم و یک regex را روی آن اجرا کنیم.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>rules</span>:
  - <span style=color:#f92672>id</span>: <span style=color:#ae81ff>password-in-func-name</span>
    <span style=color:#f92672>languages</span>:
      - <span style=color:#ae81ff>go</span>
    <span style=color:#f92672>message</span>: <span style=color:#ae81ff>Find functions that have password in their name.</span>
    <span style=color:#f92672>patterns</span>:
      - <span style=color:#f92672>pattern</span>: |<span style=color:#e6db74>
</span><span style=color:#e6db74>          func $FUNC(...) {
</span><span style=color:#e6db74>            ...
</span><span style=color:#e6db74>          }</span>          
      - <span style=color:#f92672>metavariable-regex</span>:
          <span style=color:#f92672>metavariable</span>: <span style=color:#ae81ff>$FUNC</span>
          <span style=color:#f92672>regex</span>: <span style=color:#ae81ff>.*password.*</span>
    <span style=color:#f92672>severity</span>: <span style=color:#ae81ff>ERROR</span>
</code></pre></div><p>ولی باز هم کار نمی‌کند چون regex به صورت case-sensitive اجرا می‌شود. برای اجرای آن به صورت case-insensitive می‌توانیم از inline flag استفاده کنیم.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>regex</span>: <span style=color:#ae81ff>(?i).*password.*</span>
</code></pre></div><p>و جوابمان را گرفتیم.</p><p><img loading=lazy src=12-password-match-2.png alt></p><h2 id=چی-یاد-گرفتیم>چی یاد گرفتیم؟<a hidden class=anchor aria-hidden=true href=#چی-یاد-گرفتیم>#</a></h2><p>یاد گرفتیم که با استفاده از Semgrep راحت‌تر داخل کد جستجو کنیم. با Semgrep کارهای خیلی عجیب غریبی کرده‌ام که خودم هم باورم نمی‌شود. شما هم می‌توانید از این ابزار مجانی در کار خود استفاده کنید و به قولی sky is the limit.</p><p>نقشه من برای بلاگ بعدی:</p><ol><li>چرا از Semgrep (مثلا به جای CodeQL) استفاده می‌کنم.</li><li>چگونه از Semgrep در CI/CD استفاده می‌کنم.</li></ol></div><footer class=post-footer></footer></article></main><footer class=footer><span>تحت مجوز <a href=https://creativecommons.org/licenses/by-nc/4.0/>کریتیو کامنز اختیار-غیرتجاری 4.0 بین‌المللی</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/parsiya.fa/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>